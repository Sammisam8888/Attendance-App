from datetime import datetime, timedelta
from flask import send_file
from config import secrect_key
import qrcode
import time
import io
from database import db
import hashlib

def generate_token(timestamp):
    expires_at = datetime.fromtimestamp(timestamp) + timedelta(seconds=20)
    raw=f"{stream}:{year}:{semester}:{branch}:{section}:{subject_id}:{teacher_id}:{classroom}:{timestamp}:{secrect_key}"
    hash_value=hashlib.sha256(raw.encode()).hexdigest()
    
    db.qr_sessions.insert_one({
    "stream": stream,
    "year": year,
    "semester": semester,
    "branch": branch,
    "section": section,
    "subject_id": subject_id,
    "teacher_id": teacher_id,
    "classroom": classroom,
    "timestamp": timestamp,
    "hash": hash_value,
    "expires_at": timestamp + 20
})
    qr_data=f"semester={semester};branch={branch};section={section};timestamp={timestamp};hash={hash_value}"
    img = qrcode.make(qr_data)
    buf = io.BytesIO()
    img.save(buf)
    buf.seek(0)
    return send_file(buf, mimetype='image/png')

# | Field        | Purpose                                                                  |
# | ------------ | ------------------------------------------------------------------------ |
# | `reg_no`     | Identifies the student scanning the code (or could be added from app).   |
# | `timestamp`  | Captures the exact time the QR was generated. Helps check expiry.        |
# | `subject`    | Ensures QR is tied to a particular subject's attendance.                 |
# | `classroom`  | Helps prevent students from marking attendance from other locations.     |
# | `session_id` | A random string generated by the teacher/session to validate uniqueness. |

def validator_token(data):
    max_skew=30
    try:
        parts=dict(item.split("=") for item in data.split(";"))
        timestamp=int(parts["timestamp"])
        
        semester = parts["semester"]
        branch = parts["branch"]
        section = parts["section"]
        timestamp = int(parts["timestamp"])
        received_hash = parts["hash"]
        current_ts=int(time.time())
        if(abs(current_ts-timestamp)>max_skew):
            return {"message":"QR code expired"}
        qr_session = db.qr_sessions.find_one({
            "semester": semester,
            "branch": branch,
            "section": section,
            "timestamp": timestamp
        })

        if not qr_session:
            return {"message": "QR session not found", "status": "failed"}, 400

        # Recompute hash and compare
        expected_raw = f"{qr_session['stream']}:{qr_session['year']}:{semester}:{branch}:{section}:{qr_session['subject_id']}:{qr_session['teacher_id']}:{qr_session['classroom']}:{timestamp}:{secrect_key}"
        expected_hash = hashlib.sha256(expected_raw.encode()).hexdigest()

        if received_hash != expected_hash:
            return {"message": "Invalid hash", "status": "failed"}, 400

        return {
            "message": "QR Validated"
        }, 200

    except Exception as e:
        return {"message": f"Error: {str(e)}", "status": "error"}, 500

    
    
    
